# 가장 긴 바이토닉 부분 수열
- 백준 11054
- 240415 solved

## 문제 설명
문제
수열 S가 어떤 수 Sk를 기준으로 S1 < S2 < ... Sk-1 < Sk > Sk+1 > ... SN-1 > SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.

예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.

수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)

출력
첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.

## 생각
1. 일단 n <= 1000 이므로 O(N^2)에 풀어도 됨. -> 이분탐색까지 적용할 필요는 없을듯.
그냥 기존 O(N^2)방식에 memory 배열에 row 하나 추가해 2*n 이차원 배열로 만들고, 두번째 행에는 증가중인지, 감소중인지 저장하면 될듯. 그리고 각 arr[i]가 이전 요소들과 비교할때 감소중이면 작은지, 증가중이면 더 큰지를 보면 될듯.
- 증가중일땐 감소중으로 상태 바꿀 순 있지만 그 역은 안된다는 점 유의.
-> 실패. 한번 감소로 판단한 수를 이후 증가하는 수열에 사용할 수 없음.
2. 그럼 lis[][]를 이차원 배열로 두지만 첫번째 행에는 증가할때의 lis를, 두번째 행에는 감소중인 상태의 lis를 저장하면?
- 증가중인 lis -> 이후 증가/감소 lis에 모두 사용가능 / 감소중인 lis -> 이후 감소 lis에만 사용가능.
- 이렇게 하니 해결!

## test case
10
1 5 2 1 4 3 4 5 2 1

7
1 2 3 4 3 2 1

4
4 3 2 1

4
1 2 3 4

11
1 -5 2 -4 3 -3 4 -2 5 -1 0

4
1 5 2 3

1
1
- 이것때문에 틀렸었음 ㅋㅋㅋㅋ
- maxLength 설정이 for loop 안에서 해서 n < 2 이면 초기화가 안됐음. maxLength 기본값 1로 설정해서 해결함.