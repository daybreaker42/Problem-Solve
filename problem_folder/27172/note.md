# 수 나누기 게임

- 백준 27172
- <https://www.acmicpc.net/problem/27172>
- 240429 solved

## 생각

1. 브루트포스로 풀면 시간초과가 날 것 같다. - O(N^2)
2. 정렬과 분리 집합을 이용한 방법 - O(NlogN)
    - 아이디어:
        1. 모든 자연수는 자기 자신보다 작거나 같은 수로만 나누어 떨어진다.
        2. a > b 인 a가 b로 나누어 떨어진다면, a는 b의 어떤 약수로도 나눌 수 있다.
    - 먼저 수를 정렬한 배열을 하나 만든다. - `sorted`
    - 그리고 각 수와 그 수를 나눌 수 있는 수의 개수의 정보를 가지고 있는 배열을 하나 만든다. (스택 배열로 만들면 될듯) - `divisor`
    1. 정렬된 배열(sorted)을 순회하면서 divisor에 있는 각 수에 대해 해당 수로 그 수를 나눌 수 있는지 구한다.
        1.1. 나눌 수 있다면, 그 수를 나누고 point로직을 실행. 그 후 나눈 수를 divisor의 해당 수 꼭대기에 추가한다.
        1.2. 나눌 수 없다면, 그 수를 divisor 배열에 추가한다.
    2. arr을 순회하면서, 해당 수의 sorted idx를 이분탐색으로 찾으면서 그 수에 대응하는 point를 출력한다.
-> 이렇게 하니 한 수를 나눌 수 있는 수가 하나가 아닐 때 문제가 발생.
3. 소인수분해와 이진 탐색(또는 해시 셋)을 이용한 방법 - `O(Nsqrt(M)logN)`
    - `N`은 들어오는 수의 개수, `O(sqrt(M))`은 소인수분해 시간복잡도, `M`은 들어오는 수의 최대값 (`10^6`)
    - 아이디어:
        1. 배열의 각 수를 순회하면서 해당 수를 소인수분해해서 약수들을 구한다.
        2. 그 약수들 중 입력받은 수들 중 있는게 몇개인지 확인하면 됨. - 이때, 소인수분해는 O(sqrt(M)), 이진탐색으로 찾으면 O(logN) 이므로 전체 시간복잡도는 O(Nsqrt(M)logN)이다.
    1. 각 수를 돌면서 해당 수를 소인수분해한다.
    2. 소인수분해해서 얻은 약수들을 기존 배열에서 이진탐색(또는 해시셋)으로 찾아서 만약 있다면 point를 증감시킨다.
        - 이진탐색으로 찾은 수의 idx를 구하는데 이때 `pair<int, int>`로 구성된 배열을 만들어서 해당 수와 idx를 저장, 원래의 idx를 알 수 있게 했다.
    3. point를 출력한다.

## test case

```
3
3 4 12
ans: 1 1 -2
```

```
4
1 2 3 4
ans: 3 0 -1 2
```

```
5
5 4 3 2 1
ans: -1 -2 -1 0 4
```
