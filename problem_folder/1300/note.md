# K번째 수 (해결됨)
- 백준 1300 / https://www.acmicpc.net/problem/1300
- 240411 solved

## 문제 조건, 설명
시간제한: 2초
메모리 제한: 128MB

### 문제
세준이는 크기가 N×N인 배열 A를 만들었다. 배열에 들어있는 수 A[i][j] = i×j 이다. 이 수를 일차원 배열 B에 넣으면 B의 크기는 N×N이 된다. B를 오름차순 정렬했을 때, B[k]를 구해보자.

배열 A와 B의 인덱스는 1부터 시작한다.

### 입력
첫째 줄에 배열의 크기 N이 주어진다. N은 105보다 작거나 같은 자연수이다. 둘째 줄에 k가 주어진다. k는 min(109, N2)보다 작거나 같은 자연수이다.

### 출력
B[k]를 출력한다.

## 생각
- 여러 가지 방법으로 생각해봄
1. naive하게 A[][] 의 모든 수를 순회하는 알고리즘
    1. A[][]의 모든 수를 구한다 - O(N^2)
    2. A[][] 안에 있는 수를 정렬한다 - O(N^2 * lg(N^2))
    3. B[k]를 구한다 - O(1)
    - 총 O(N^2 * lgN)으로 해결 불가능
- 평범한 방법으로는 못 구함.
- 심지어 A[][]를 구하기만 해도 O(N^2)이 나와버림... -> A[][]의 모든 수를 구하지 않고도 문제를 해결해야 함.
- 그럼 O(N^2) 내로 풀 수 있다는 건데...음..
- 그럼 해당 문제 조건에서 특징은 뭐가 있지?
    1. A[][]에 있는 수들은 1~N*2의 범위 내의 자연수에 속한다.
    2. A[][]안에는 1~N^2까지의 제곱수가 모두 포함된다.
    3. A[][]안에 있는 모든 수는 1~N까지의 수들 중 적어도 두 개를 약수로 가진다(1 제외)
    4. B[1] == 1, B[N^2] == N^2
    5. 어떤 k에 대해서도 B[k] <= k
    6. 1~N^2 까지 n개의 제곱수에 대해서만 각 숫자는 1번씩만 등장, 나머지 수들은 최소 2개씩 항상 짝수개로 등장.
    7. ***각 수는 1~N 사이의 약수의 개수의 개수만큼 등장함 (제곱이면 한개)***
    8. ***해당 수보다 작은 수의 개수는 1~n까지 반복하며 min(i * n, 해당 수를 나눈 몫의 합)으로 구할 수 있다.*** - O(N)으로 해당 수보다 작은 수의 개수를 구할 수 있음. (작거나 같은 수의 개수도)
        - 어떤 수가 A에 포함됐는지 확인하려면 8.의 방법을 사용해서 할 수 있다. 작거나 같은 수의 개수 == 작은 수의 개수 이면 A에 없는 것.
        - O(sqrt(N))으로도 구할 수 있음. - x의 약수를 구하고 (O(sqrt(x))), 그 약수들이 각각 1~N 사이 범위에 있는지 확인하면 됨. -> O(sqrt(x))
2. N^2보다 작은 수들의 개수를 구할 수 있다면, 각 i^2 (i: 1~N)들이 몇 번째인지를 구해 B[k]를 추정할 수 있지 않을까?
-> N^2보다 작은 수의 개수를 구하는데 O(1)이 아닌 O(N)이 걸리므로 불가능.
3. N-1의 경우에서 B[k]를 구하고, 이를 N의 경우에서 연관지어 dp처럶 구할 수 있지 않을까?
-> 연관성 찾기 실패
4. y = s / x 형태로 해당 그래프 아래 있는 수의 개수를 O(N) 미만에 구할 수 있다면...
-> 실패
5. 일단 특징 8. 에서 해당 수가 몇 번째인지는 알 수 있음 (+ A안에 속하는지 여부도). 그렇다면 이분탐색을 이용, 1~N^2범위 내에서 이분탐색을 하며 k번째인 수 x를 찾아간다면?
    - 이분탐색 시간복잡도 = O(lgN^2) = O(2lgN) = O(lgN)
    - 해당 수 x가 몇 번째인지 찾는 시간복잡도 = O(N)
    -> O(N * lgN) 안에 해결가능?
    - smallerNumbersCount()에서 lineCnt의 범위가 <= n이 되어야 함. -> min(x / i, i * n)이 아닌 min(x / i, n)으로 바꿔줌.
    - 중간에 N*2 이 int의 범위를 넘어가 overflow가 생기는 문제 발생.
    -> 성공함