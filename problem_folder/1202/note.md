# 보석 도둑
- 백준 1202
- solving: 240407~240424 solved

## 생각
1. 가방은 총 k개 주어짐.
- 작은 가방에 넣을 수 있는 보석은 그보다 큰 가방에 넣을 수 있지만, 그 역은 성립 안 함.
    1. 일단 작은 가방부터 보석을 담으면서 최대한 담는 방향으로 진행? -> 그리고 다 담았으면 그 합을 구하기.
- 반례) 마지막에 남은 보석 하나가 남은 보석들 전부의 가격을 다 합친것보다 value가 높으면?
    ㄴ 근데 이 방법으로 남은 보석은 어차피 아무 가방에도 들어갈 수 없음. 각 가방마다 최대로 가능한 보석을 담았는데 거기서 남은 어떤 보석을 선택한 보석 대신 넣어도 손해밖에 안남(4/23)
    2. 그럼 가격이 높은 보석부터 담아야 하나?
- 근데 그럼 또 1.이 가격 합이 더 높아질 수가 있음.
    3. 가격이 높은 보석부터 담되, 각 보석은 들어갈 수 있는 최소 가방에 담으면 될듯? 그러면 각 가방에 들어가는 보석의 value는 해당 가방에 넣을 수 있는 보석들 중 최대가 됨.

-> 알고리즘
    1. 보석을 가격순으로 내림차순 정렬.- O(nlogn)
    2. 가방을 최대허용무게순으로 오름차순 정렬 - O(NlogN)
    3. 각 보석을 '넣을 수 있는'(사용하지 않은) 가장 작은 가방에 넣기
    - 여기가 문제
    시간복잡도 = 보석의 수 N * 넣을 수 있는 가장 작은 가방 찾기 인데,
    가능한 작은 가방을 찾는게 O(N)미만으로 나와야함. 근데 그게 쉽지가 않음..
    가방을 용량순으로 미리 정렬하고 이진탐색하면 O(NlogN), O(logN)이 걸리지만, 가방 사용 여부를 따지게 되면 이진탐색으로 찾고난 뒤, 거기서부터 타고 계속 올라가기게 O(N)이 걸리게 되버림.
    -> 그럼 사용한 가방 배열을 만들고, 거기서 이분탐색을 하면서 들어갈 수 있는 가장 작은 idx를 구한다면?
    ㄴ근데 배열에 push할때 O(N)이 걸려버림..
    -> 사용한 가방으로 priority_queue를 만들고, 거기서 minBagIdx가 나올때까지 pop을 하면서 idx를 구할 때의 시간복잡도는?
    4. 정답 출력

2.가방, 보석 모두 무게 기준 오름차순으로 정렬한 뒤
보석의 각 요소 순회하면서
- 첫번째 보석은 이진탐색으로 사용할 수 있는 최소 가방의 인덱스 찾음
- 다음 보석부턴 첫번째 보석의 다음 인덱스부터 순차탐색, 자기 무게보다 큰 가방 나오면 해당 가방에 넣고 넘김
- 이렇게 보든 보석 순회하면서 가격 합 구하기
-> 이렇게 간다면..?
-> 일단 O(k + N)에 해결가능. 
다만 반례가 
    1. n > k이고 마지막 보석의 가치가 제일 높을 때

3. 근데 그냥 naive하게 생각하면 작은 가방부터 각 가방이 가질 수 있는 최대 보석을 가져가면 되는거 아닌가?
    1. 가방 오름차순 정렬
    2. 보석 무게로 오름차순 정렬
    3. 각 가방마다 들어갈 수 있는 보석 최소 idx, 최대 idx 이분탐색으로 구함 (최소idx >= n -> 다음 가방으로 넘어가기, 최대idx <= 0이면 그냥 최고 가치 보석 return)
    4. 해당 범위 전부 순회하면서 최고 가치 보석 찾기 -> 해당 보석 안담았다면 담기
    5. 정답 출력
    -> 맞음. 다만 해당 알고리즘으로는 시간초과가 남.

## 정답 알고리즘 도출해낸 계기
1. 일단 위의 3.의 방법으로 시도했지만 실패
2. 어떻게 하면 해당 보석의 무게 이하인 gem중에서 가장 가치가 높은 보석들만 뽑을 수 있을지 고민.
3. 문제를 이미지화시켜서 가방들을 열에, 보석을 행에 무게 오름차순으로 배치, 각 가방들마다 가능한 보석들이 어떻게 되는지 생각함.(이차원 배열열
4. 그러다가 이전 가방에 들어갈 수 있는 보석은 이후 가방에 무조건 들어갈 수 있다는 특징을 발견.
5. 생각 좀 더 해봄.
6. 그러다 가방을 정렬한 배열을 순회할때, 이전 가방에서 검사한 보석들은 "중복"되어 다음 가방에 추가로 넣을 수 있는 보석들만 추가로 검사하면 된다는 사실을 깨달음. -> 해당 정보로 문제를 풀 수 있을 것 같다는 느낌을 받음
7. 그러면 해당 가방까지의 최대 보석 정보에 새로 검사한 보석 정보만 넣어주면 됨 -> 근데 이걸 어떻게 저장하지? 단순히 최댓값만 저장하는게 아니라 이전 최댓값들에 대한 정보도 저장해야 하는데 -> "우선순위큐 사용"
8. 그럼 각 가방을 순회하면서 이전까지의 정보를 우선순위큐에 집어넣고, 현재 가방의 용량보다 작은 보석들만 들어가 있으니 그중 최댓값만 바로 뽑아 ans에 출력 -> 해당 보석은 queue에서 pop -> 다음 가방은 해당 가방보다 작은 값들 집어넣고 다시 최대 보석 구하기 -> 반복 -> 문제 해결

## 정답 알고리즘
1. 가방, 보석을 모두 무게 오름차순으로 정렬함
2. 우선순위큐는 보석의 가치 내림차순으로 뽑히게 설정함
3. 각 가방을 돌면서 해당 가방보다 작거나 같은 보석들을 보석 arr을 돌면서 우선순위큐에 넣음
4. 해당 우선순위큐에 있는 값중 하나를 뽑아 ans에 추가함(여기서 우선순위큐에 있는 값은 모두 해당 가방의 용량보다 무게가 작은 gem밖에 없음)
5. ans 출력


## test case

6 5
1 40
4 30
4 20
1 10
1 10
1 10
1
2
3
4
5