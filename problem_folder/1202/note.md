# 1202 - 보석 도둑

## 생각
- 가방은 총 k개 주어짐.
- 작은 가방에 넣을 수 있는 보석은 그보다 큰 가방에 넣을 수 있지만, 그 역은 성립 안 함.
    1. 일단 작은 가방부터 보석을 담으면서 최대한 담는 방향으로 진행? -> 그리고 다 담았으면 그 합을 구하기.
- 반례) 마지막에 남은 보석 하나가 남은 보석들 전부의 가격을 다 합친것보다 value가 높으면?
    2. 그럼 가격이 높은 보석부터 담아야 하나?
- 근데 그럼 또 1.이 가격 합이 더 높아질 수가 있음.
    3. 가격이 높은 보석부터 담되, 각 보석은 들어갈 수 있는 최소 가방에 담으면 될듯? 그러면 각 가방에 들어가는 보석의 value는 해당 가방에 넣을 수 있는 보석들 중 최대가 됨.

-> 알고리즘
1. 보석을 가격순으로 내림차순 정렬.- O(nlogn)
2. 가방을 최대허용무게순으로 오름차순 정렬 - O(NlogN)
3. 각 보석을 넣을 수 있는 가장 작은 가방에 넣기
- 여기가 문제
시간복잡도 = 보석의 수 N * 넣을 수 있는 가장 작은 가방 찾기 인데,
가능한 작은 가방을 찾는게 O(N)미만으로 나와야함. 근데 그게 쉽지가 않음..
가방을 용량순으로 미리 정렬하고 이진탐색하면 O(NlogN), O(logN)이 걸리지만, 가방 사용 여부를 따지게 되면 이진탐색으로 찾고난 뒤, 거기서부터 타고 계속 올라가기게 O(N)이 걸리게 되버림.
-> 그럼 사용한 가방 배열을 만들고, 거기서 이분탐색을 하면서 들어갈 수 있는 가장 작은 idx를 구한다면?
ㄴ근데 배열에 push할때 O(N)이 걸려버림..
-> 사용한 가방으로 priority_queue를 만들고, 거기서 minBagIdx가 나올때까지 pop을 하면서 idx를 구할 때의 시간복잡도는?
4. 정답 출력