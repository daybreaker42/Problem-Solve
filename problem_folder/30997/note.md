## 생각

- 일단 i가 추첨될 확률에서 분모는 3*M임
- 주인공이 고른 것도 확률에 포함이 되나? 근데 어차피 고르기 전/후로 최대 높은 확률인거 고를거라 상관은 없는데 계산은 다시 해야함
- 사람들이 많이 고른 숫자일수록 추첨될 확률이 높아짐
- 총 K+1번 추첨, K번 추첨땐 숫자 안나와야 하고 마지막 1번에서 숫자 나와야함.
- k=> 1~5, 그렇다면,
    - k==1일때
    1. 한번 추첨 후 다시 보너스 추첨.
    2. 이때 당첨 확률
        ```
        ex) N, M=5, K=1
        [3 3 3 3 3]일때 -> 모두 추첨확률 0.2

        숫자가 X1~Xn까지 있다고 하면 그중 서로 다른 3개를 가지고 있음 -> A, B, C
        당첨확률 = A, B, C가 처음에 모두 나오지 않을 확률 * A, B, C가 두번째에 하나라도 나올 확률
        = (1 - sum(확률 A, 확률 B, 확률 C)) * (sum(확률 A, 확률 B, 확률 C))
        = (1 - 0.6) * 0.6
        = 0.24
        ```
    - k==2일때
    ```
    당첨확률 (A, B, C가 모두 안나올 확률 = a라고 하면)
    = a * a * (1 - a)
    이때 a = (1 - A추첨확률 - B추첨확률 - C추첨확률)
    ```
    - k == n일때
    ```
    당첨확률 = a^k*(1 - a)
    이때, 극점은 k/k+1
    ```
    - 결론: k가 커질수록 추첨 확률이 적을수록 대체로 유리. 정확히는 (1-ABC추첨확률합)이 k/k+1에 가까울수록 유리하다.
- 3개 숫자 고르는건 겹치면 안됨
- 근데 어차피 3개 서로 다른거 고른다면 -> 결과적으로 당첨확률엔 주인공이 고른 숫자만 확률에 포함됨 -> 그냥 모두 한개씩 골랐다고 생각하고, 최종 당첨 확률을 찾아가면 안되나?

1. 각 숫자별로 고른 횟수 저장 (N 크기 배열)
2. 서로 다른 숫자 3개를 고르는 모든 조합을 brute force, 당첨 확률이 최대한 높은 조합 찾기 (O(N^3), NC3번 반복; N<=100이므로 최대 계산은 100만번 이하임)

맞는데 뭐지??