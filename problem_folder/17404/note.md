# RGB거리 2

- 백준 17404
- <https://www.acmicpc.net/problem/17404>
- 240429~

### 문제

RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번, N번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번, 1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1, i+1번 집의 색과 같지 않아야 한다.

### 입력

첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

### 출력

첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

## 생각

1. DP를 이용한 풀이 - O(N)
    - 아이디아: 첫 번째 집이랑 두 번째 집, n번째 집만 따로 조건을 걸고, 나머지는 앞의 두 개의 집을 보고 비용을 결정.
2. 어차피 0, 1, n - 1번째만 정하면, 그 가운데는 알아서 정해지는거 아닌가?

- 이렇게 해서 3! = 6가지 경우만 계산하면 안되나?
-> 이건 안함..

### 241125 생각

- 제한 시간: 0.5초
- 메모리 제한: 128MB
- 2 <= N <= 1000
- 집당 cost <= 1000

- 일단 brute force로 계산하면 총 가짓수는 
처음 - 3가지
두번째~n-1번째 - 2가지
마지막 - 1가지
-> O(3 * 2^(n-2) * 1) = O(2^n)

하지만 문제에서 N <= 1000이므로, 이 방법은 불가능하다.

- 그렇다면 DP를 사용한다면?
- 일단 i +- 1번째 집이랑 다른거나, i 랑 i-1, i-2번째 집이랑 다른거랑 같음. 
-> 그냥 연속된 3개 집 색이 다르기만 하면 됨.

- DP -> 어차피 각 셀에 저장해야 하는 건 지금까지의 경로 중 최소의 경로. 하지만 무턱대로 최소인 경로만 저장하면 local minimum만 저장하고 global minimum을 찾을 수 없을 수 있음.
- global minimum까지 챙기는 방법은 결국 1번째에 선택할 수 있는 색들 3개에 대해 각각의 최소값들을 저장하면 됨.
-> 이렇게 하면 각 경우에서 1번째에 같은 색을 선택한 경우 중 최솟값만 저장할 수 있음.

```
n * 3 * 3 배열을 만들고, (n * 3 이차원 배열에서 한 cell에 3가지 경우가 있다고 생각) 
각 칸에 1~3번 칸(n번 칸)에는 현재 선택할 수 있는 이전 노드의 값들 중 n번노드를 선택한 값 중 최소값만 저장
마지막 칸에선 이전 칸에서 선택할 수 있는 값들 중 현재 색상과 다른 1번 색상이 있는 값들 중 최소값만 고르면 됨

해결!!
```
## test case

3
26 40 83
49 60 57
13 89 99

2
1 1 1
1 1 1

2
1 1 1
1 2 2

3
1 1 1
1 1000 1000
1000 1 1000

## 1. 초기 코드

    int ans = 0;
    for (int i = 0; i < n; i++){
        for (int j = 0; j < 3; j++){
            if(i == 0){
                result[i][j][0] = cost[i][j];
                result[i][j][1] = cost[i][j];
            }else if(i == 1){
                result[i][j][0] = result[i - 1][mod_3(j - 1)][0]  + cost[i][j];
                result[i][j][1] = result[i - 1][mod_3(j + 1)][1]  + cost[i][j];

            }else if(i == n - 1){
                result[i][j][0] = result[i - 1][mod_3(j - 1)][0] + result[0][mod_3(j + 1)][0] + cost[i][j];
                result[i][j][1] = result[i - 1][mod_3(j + 1)][1] + result[0][mod_3(j - 1)][1] + cost[i][j];
            }else{
                result[i][j][0] = result[i - 1][mod_3(j - 1)][0] + result[i - 2][mod_3(j + 1)][0] + cost[i][j];
                result[i][j][1] = result[i - 1][mod_3(j + 1)][1] + result[i - 2][mod_3(j - 1)][1] + cost[i][j];
            }
        }
    }
    cout << "cost" << endl;
    for (int j = 0; j < 3; j++){
        for (int i = 0; i < n; i++){
            cout << cost[i][j] << " ";
        }
        cout << endl;
    }
    cout << endl;
    cout << "result" << endl;
    for(int k = 0; k < 2; k++){
        cout << "k : " << k << endl;
        for (int j = 0; j < 3; j++){
            for (int i = 0; i < n; i++){
                cout << result[i][j][k] << " ";
            }
            cout << endl;
        }
        cout << endl;
    }
    cout << endl;

    ans = result[n - 1][0][0];
    for (int k = 0; k < 2; k++){
        for (int i = 0; i < 3; i++){
            ans = min(ans, result[n - 1][i][k]);
        }

    }
