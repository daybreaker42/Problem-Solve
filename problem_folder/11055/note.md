# 11055 - 증가하는 부분 수열 중 합이 가장 큰 부분 수열의 합을 출력하는 문제
- 풀이 기간: 240407~240407

## 생각

- 2 * n + 1 크기로 만들어 밑에 합을 따로 저장하도록?
근데 기존 방식으로 하면 작은 수가 큰 수를 대체해버림
- 아님 maxSum하나만 구하면 되니까 maxSum하나만 저장하고, 나머진 기존 방식으로 lis에 숫자 넣을때 합만 따로 구하게 하면 될수도?
- counting sort처럼 큰 배열을 하나 만들고 거기에 각 합에 해당하는 인덱스에 마지막 숫자 저장하게 해도 될 것 같은데... 공간이 문제. 최대 합 100만이므로 100만 * 4 byte = 4백만 bype = 4gb > 256mb 이므로 문제 조건 초과. 그리고 이진탐색시에도 별로 좋지 않음.
- lis 이차원배열로 만드록, 합을 저장하면? 대신 오늘 푼 방법이 아닌 이전에 푼 방법을 사용(0 <= k <= i, array[k] < array[i]인 k를 찾고 lis[k]의 sum에 array[i]를 더함). maxSum하나 두고 sum 구할때마다 업데이트 해도 되고, 아니면 마지막에 array 한번 돌면서 max값 구해도 됨.
-> 근데 이러면 이분탐색으로 위치를 찾을 수 없음. 기존 값들 다 보면 O(N^2)됨
-> N <= 1000이므로 상관없을 듯. ㄱㄱ
-> 근데 그럼 그냥 1차원 배열로 하고, 배열의 각 자리에 그냥 arr[i]가 가질 수 있는 최대 합을 저장하면 되는게 아닌가? 비교는 어차피 0~i돌면서 다 하고, 길이는 여기서 의미가 없고, 마지막 숫자도 어차피 0~i다 돌거면 그 사이에 포함되어있고.
-> 성공.

## 결론
- 기존 방법에선 길이를 저장했다면, 여기선 필요없어진 길이 요소 대신 합을 저장하는 방식으로 풀이 진행.
- N 범위가 줄어들었기에 이중for문이 사용가능함을 판단할 수 있었고, 역으로 이를 파악할 수도 있었을듯. 그리고 어차피 각 arr[i]마다 이전 요소들 전역탐색 진행해야해서 O(N^2)은 필연적이었음.

### test case

5
1000 1 2 3 4
ans: 1000 / 기존 방식으로 하면 10

6
1 1000 2 900 3 800
ans: 1001 / 근데 기존 방식으로 하면 806이 나옴;
